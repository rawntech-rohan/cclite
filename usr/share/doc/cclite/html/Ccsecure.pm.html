<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Ccsecure.pm</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<style type="text/css">
<!--
/* default style sheet generated by perltidy */
body {background: #FFFFFF; color: #000000}
pre { color: #000000; 
      background: #F0F0F0;
      font-family: courier;
    } 

.c  { color: #228B22;} /* comment */
.cm { color: #000000;} /* comma */
.co { color: #000000;} /* colon */
.h  { color: #CD5555; font-weight:bold;} /* here-doc-target */
.hh { color: #CD5555; font-style:italic;} /* here-doc-text */
.i  { color: #00688B;} /* identifier */
.j  { color: #CD5555; font-weight:bold;} /* label */
.k  { color: #8B008B; font-weight:bold;} /* keyword */
.m  { color: #FF0000; font-weight:bold;} /* subroutine */
.n  { color: #B452CD;} /* numeric */
.p  { color: #000000;} /* paren */
.pd { color: #228B22; font-style:italic;} /* pod-text */
.pu { color: #000000;} /* punctuation */
.q  { color: #CD5555;} /* quote */
.s  { color: #000000;} /* structure */
.sc { color: #000000;} /* semicolon */
.v  { color: #B452CD;} /* v-string */
.w  { color: #000000;} /* bareword */
-->
</style>
<body style="background-color: white">
<a name="-top-"></a>
<h1>Ccsecure.pm</h1>

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#copyright">COPYRIGHT</a></li>
	<ul>

		<ul>

			<li><a href="#_get_digest">_get_digest</a></li>
			<li><a href="#text_to_hash">text_to_hash</a></li>
			<li><a href="#compare_password">compare_password</a></li>
			<li><a href="#calculate_token">calculate_token</a></li>
			<li><a href="#valid_token">valid_token</a></li>
			<li><a href="#calculate_api_key">calculate_api_key</a></li>
			<li><a href="#compare_api_key">compare_api_key</a></li>
			<li><a href="#hash_password">hash_password</a></li>
			<li><a href="#get_server_details">get_server_details</a></li>
			<li><a href="#log_violation">log_violation</a></li>
			<li><a href="#random_password">random_password</a></li>
			<li><a href="#grumble">grumble</a></li>
			<li><a href="#is_admin">is_admin</a></li>
		</ul>

	</ul>

</ul>
<!-- INDEX END -->
<h2>Code Index:</h2>
<!-- BEGIN CODE INDEX --><a name="code-index"></a>
<ul>
<li><a href="#package-Ccsecure-">package Ccsecure</a>
<ul>
<li><a href="#_get_digest-">_get_digest</a></li>
<li><a href="#text_to_hash-">text_to_hash</a></li>
<li><a href="#compare_password-">compare_password</a></li>
<li><a href="#calculate_token-">calculate_token</a></li>
<li><a href="#valid_token-">valid_token</a></li>
<li><a href="#calculate_api_hash-">calculate_api_hash</a></li>
<li><a href="#compare_api_key-">compare_api_key</a></li>
<li><a href="#hash_password-">hash_password</a></li>
<li><a href="#get_server_details-">get_server_details</a></li>
<li><a href="#log_violation-">log_violation</a></li>
<li><a href="#random_password-">random_password</a></li>
<li><a href="#install_grumble-">install_grumble</a></li>
<li><a href="#is_admin-">is_admin</a></li>
<li><a href="#encode_base64-">encode_base64</a></li>
<li><a href="#decode_base64-">decode_base64</a></li>
</ul>
</li>
<li><a href="#EOF-">EOF</a></li>
</ul>
<!-- END CODE INDEX -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Ccsecure.pm</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<p>Security routines for Cclite</p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>This package deals with session and security management. Currently sessions
are via tokens. Tokens are hashes of IP address and validated password.
They shouldn't work from a new address by being transported.</p>
<p>Action completes OK or it's a violation. If it's a violation, it's logged.</p>
<p>Note that nearly every other routine within Cclite can consume a token.
This is usually the last input paramter for any given subroutine.</p>
<p>This isn't used at present but the idea is many watertight doors rather
than a perimeter and a leaky interior.</p>
<p>I expect to put public key processing for GPG email
and similar here too.</p>
<p>This can now use the pure Perl SHA package.
The idea is to enable a full installation where a user may not be able
to use CPAN. However Digest::SHA2 will be much faster.</p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Hugh Barnard</p>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<p>(c) Hugh Barnard 2005 GPL Licenced</p>
<pre>
<span class="c">#</span>
<a name="package-Ccsecure-"></a><span class="k">package </span><span class="i">Ccsecure</span><span class="sc">;</span>

<span class="k">use</span> <span class="w">strict</span><span class="sc">;</span>
<span class="k">use</span> <span class="w">vars</span> <span class="q">qw(@ISA @EXPORT)</span><span class="sc">;</span>
<span class="k">use</span> <span class="w">Exporter</span><span class="sc">;</span>
<span class="k">use</span> <span class="w">Ccu</span><span class="sc">;</span>
<span class="k">use</span> <span class="w">Cclitedb</span><span class="sc">;</span>
<span class="k">use</span> <span class="w">Cccookie</span><span class="sc">;</span>
<span class="c">###use GnuPG qw( :algo );</span>

<span class="k">my</span> <span class="i">$VERSION</span> = <span class="n">1.00</span><span class="sc">;</span>
<span class="i">@ISA</span>    = <span class="q">qw(Exporter)</span><span class="sc">;</span>
<span class="i">@EXPORT</span> = <span class="q">qw(login</span>
  <span class="q">logout</span>
  <span class="q">hash_password</span>
  <span class="q">get_server_details</span>
  <span class="q">install_grumble</span>
  <span class="q">is_admin</span>
  <span class="q">compare_password</span>
  <span class="q">random_password</span>
  <span class="q">calculate_token</span>
  <span class="q">calculate_api_key</span>
  <span class="q">compare_api_key</span>
  <span class="q">valid_token</span>
  <span class="q">parse_remote_user</span>
  <span class="q">log_violation</span>
  <span class="q">text_to_hash</span>
  <span class="q">encode_base64</span>
  <span class="q">decode_base64</span>
<span class="q">)</span><span class="sc">;</span>

<span class="c"># this will choose the hashing module type, hash processing</span>
<span class="c"># depends on this within _get_digest</span>

<span class="k">our</span> <span class="i">$type</span><span class="sc">;</span>

<span class="k">BEGIN</span> <span class="s">{</span>
    <span class="k">eval</span> <span class="q">&quot;use Digest::SHA2&quot;</span><span class="sc">;</span>
    <span class="i">$type</span> = <span class="q">&quot;sha2&quot;</span><span class="sc">;</span>
    <span class="k">if</span> <span class="s">(</span><span class="i">$@</span><span class="s">)</span> <span class="s">{</span>
        <span class="k">eval</span> <span class="q">&quot;use Digest::SHA1&quot;</span><span class="sc">;</span>
        <span class="i">$type</span> = <span class="q">&quot;sha1&quot;</span><span class="sc">;</span>
    <span class="s">}</span>
<span class="s">}</span>

<span class="k">our</span> <span class="i">$log</span> = <span class="w">Log::Log4perl</span><span class="w">-&gt;get_logger</span><span class="s">(</span><span class="q">&quot;Ccsecure&quot;</span><span class="s">)</span><span class="sc">;</span>

</pre><p></p>
<h3><a name="_get_digest">_get_digest</a></h3>
<p>Returns a SHA digest. Digest SHA1
is potentially collision prone but available on
many commodity hosting platforms, so it's default
if cclite can't find SHA2</p>
<pre>
<a name="_get_digest-"></a><span class="k">sub </span><span class="m">_get_digest</span> <span class="s">{</span>

    <span class="k">my</span> <span class="s">(</span> <span class="i">$url_type</span><span class="cm">,</span> <span class="i">@hash_items</span> <span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$digest</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$sha2obj</span><span class="sc">;</span>
    <span class="k">if</span> <span class="s">(</span> <span class="i">$type</span> <span class="k">eq</span> <span class="q">&quot;sha2&quot;</span> <span class="s">)</span> <span class="s">{</span>
        <span class="i">$sha2obj</span> = <span class="w">new</span> <span class="w">Digest::SHA2</span> <span class="n">512</span><span class="sc">;</span>
    <span class="s">}</span> <span class="k">elsif</span> <span class="s">(</span> <span class="i">$type</span> <span class="k">eq</span> <span class="q">&quot;sha1&quot;</span> <span class="s">)</span> <span class="s">{</span>
        <span class="i">$sha2obj</span> = <span class="w">new</span> <span class="w">Digest::SHA1</span><span class="sc">;</span>
    <span class="s">}</span>
    <span class="i">$sha2obj</span><span class="i">-&gt;add</span><span class="s">(</span><span class="i">@hash_items</span><span class="s">)</span><span class="sc">;</span>
    <span class="i">$digest</span> = <span class="i">$sha2obj</span><span class="i">-&gt;b64digest</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>
    <span class="c">###$log-&gt;debug(&quot; type:$type, url type:$url_type, ip:$hash_items[1]&quot;);</span>

    <span class="c"># make base64 digest URL safe without using encoder/decoder 12/2008</span>
    <span class="c"># only do this for strings to be put into urls...</span>
    <span class="c">###$digest =~ s/([^A-Za-z0-9])/sprintf(&quot;%%%02X&quot;, ord($1))/seg if ($url_type);</span>
    <span class="c">###$digest =~ tr!\+\|\=!\\-\_! if ($url_type);    # transform dificult escapes</span>
    <span class="i">$digest</span> =~ <span class="q">s/[\+\\\s\/\|\=]+//g</span> <span class="k">if</span> <span class="s">(</span><span class="i">$url_type</span><span class="s">)</span><span class="sc">;</span>   <span class="c"># remove difficult escapes</span>
       <span class="c">#$digest = encode_base64($digest) if ($url_type);   # remove spaces newlines, experimental</span>
    <span class="k">return</span> <span class="i">$digest</span><span class="sc">;</span>
<span class="s">}</span>

</pre><p></p>
<h3><a name="text_to_hash">text_to_hash</a></h3>
<p>This is a tramp function that exposes _get_digest</p>
<pre>
<a name="text_to_hash-"></a><span class="k">sub </span><span class="m">text_to_hash</span> <span class="s">{</span>

    <span class="k">my</span> <span class="s">(</span><span class="i">$text</span><span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$url_type</span> = <span class="n">0</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$hash</span> = <span class="i">_get_digest</span><span class="s">(</span> <span class="i">$url_type</span><span class="cm">,</span> <span class="s">(</span><span class="i">$text</span><span class="s">)</span> <span class="s">)</span><span class="sc">;</span>
    <span class="k">return</span> <span class="i">$hash</span><span class="sc">;</span>

<span class="s">}</span>

</pre><p></p>
<h3><a name="compare_password">compare_password</a></h3>
<p>Compares the input hashed password with the stored one.
Normally this would take place over an https connection too.</p>
<pre>
<a name="compare_password-"></a><span class="k">sub </span><span class="m">compare_password</span> <span class="s">{</span>
    <span class="k">my</span> <span class="s">(</span> <span class="i">$password_in</span><span class="cm">,</span> <span class="i">$cleartext</span><span class="cm">,</span> <span class="i">$password_stored</span> <span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
    <span class="c">###$log-&gt;debug(&quot;compare password $password_in, $cleartext, $password_stored&quot;) ;</span>
    <span class="k">if</span> <span class="s">(</span> <span class="i">$password_in</span> <span class="k">ne</span> <span class="i">$password_stored</span> <span class="s">)</span> <span class="s">{</span>    <span class="c"># already hashed</span>
        <span class="k">return</span> <span class="n">0</span><span class="sc">;</span>
    <span class="s">}</span> <span class="k">else</span> <span class="s">{</span>
        <span class="k">return</span> <span class="n">1</span><span class="sc">;</span>
    <span class="s">}</span>
<span class="s">}</span>

</pre><p></p>
<h3><a name="calculate_token">calculate_token</a></h3>
<p>The token is a hash of the user, their current address (avoids some man
in the middle and some replay and the private value which is never exposed
to the network and changed frequently (we hope).</p>
<p>As of 2008, there's</p>
<p>The hashref is either the fields reference or the cookie reference</p>
<pre>
<a name="calculate_token-"></a><span class="k">sub </span><span class="m">calculate_token</span> <span class="s">{</span>
    <span class="k">my</span> <span class="s">(</span> <span class="i">$registry_private_value</span><span class="cm">,</span> <span class="i">$fieldsref</span><span class="cm">,</span> <span class="i">$cookieref</span><span class="cm">,</span> <span class="i">$remote_address</span> <span class="s">)</span> =
      <span class="i">@_</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$token</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$url_type</span> = <span class="n">1</span><span class="sc">;</span>    <span class="c"># these are url type hashes</span>
    <span class="k">if</span> <span class="s">(</span> !<span class="k">length</span><span class="s">(</span><span class="i">$cookieref</span><span class="s">)</span> <span class="s">)</span> <span class="s">{</span>
        <span class="k">my</span> <span class="s">(</span> <span class="i">$sec</span><span class="cm">,</span> <span class="i">$min</span><span class="cm">,</span> <span class="i">$hour</span><span class="cm">,</span> <span class="i">$mday</span><span class="cm">,</span> <span class="i">$mon</span><span class="cm">,</span> <span class="i">$year</span><span class="cm">,</span> <span class="i">$wday</span><span class="cm">,</span> <span class="i">$yday</span><span class="cm">,</span> <span class="i">$isdst</span> <span class="s">)</span> =
          <span class="k">localtime</span><span class="s">(</span><span class="k">time</span><span class="s">)</span><span class="sc">;</span>

        <span class="c">#FIXME: time gives a little volatility but improve EGD perhaps?</span>
        <span class="k">my</span> <span class="i">$nonce</span> = <span class="k">join</span><span class="s">(</span> <span class="q">&#39;&#39;</span><span class="cm">,</span> <span class="i">$sec</span><span class="cm">,</span> <span class="i">$min</span><span class="cm">,</span> <span class="i">$hour</span> <span class="s">)</span><span class="sc">;</span>
        <span class="i">$nonce</span> = <span class="i">_get_digest</span><span class="s">(</span> <span class="i">$url_type</span><span class="cm">,</span> <span class="i">$nonce</span> <span class="s">)</span><span class="sc">;</span>
        <span class="i">$token</span> = <span class="i">_get_digest</span><span class="s">(</span> <span class="i">$url_type</span><span class="cm">,</span> <span class="i">$$fieldsref</span>{<span class="q">&#39;userLogin&#39;</span>}<span class="cm">,</span>
            <span class="i">$nonce</span><span class="cm">,</span> <span class="i">$remote_address</span> <span class="s">)</span><span class="sc">;</span>
        <span class="k">return</span> <span class="s">(</span> <span class="i">$token</span><span class="cm">,</span> <span class="i">$nonce</span> <span class="s">)</span><span class="sc">;</span>
    <span class="s">}</span> <span class="k">else</span> <span class="s">{</span>
        <span class="i">$token</span> = <span class="i">_get_digest</span><span class="s">(</span> <span class="i">$url_type</span><span class="cm">,</span> <span class="i">$$cookieref</span>{<span class="q">&#39;userLogin&#39;</span>}<span class="cm">,</span>
            <span class="i">$$cookieref</span>{<span class="q">&#39;token1&#39;</span>}<span class="cm">,</span> <span class="i">$remote_address</span> <span class="s">)</span><span class="sc">;</span>

        <span class="k">return</span> <span class="s">(</span> <span class="i">$token</span><span class="cm">,</span> <span class="k">undef</span> <span class="s">)</span><span class="sc">;</span>
    <span class="s">}</span>
    <span class="i">$log</span><span class="i">-&gt;error</span><span class="s">(</span>
<span class="q">&quot;in token calc, fatal problem: $registry_private_value, u:$$fieldsref{&#39;userLogin&#39;}, ip:$remote_address&quot;</span>
    <span class="s">)</span><span class="sc">;</span>
<span class="s">}</span>

</pre><p></p>
<h3><a name="valid_token">valid_token</a></h3>
<p>recalculate the token for existing input, return true, if it still works
and compare it. Return 1 if the recalculated token is valid.</p>
<p>This is switched off at present and maybe should become dead code...</p>
<pre>
<a name="valid_token-"></a><span class="k">sub </span><span class="m">valid_token</span> <span class="s">{</span>

    <span class="k">my</span> <span class="s">(</span> <span class="i">$registry_private_value</span><span class="cm">,</span> <span class="i">$user</span><span class="cm">,</span> <span class="i">$remote_address</span><span class="cm">,</span> <span class="i">$token</span> <span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$url_type</span> = <span class="n">0</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$compare</span> =
      <span class="i">_get_digest</span><span class="s">(</span> <span class="i">$url_type</span><span class="cm">,</span> <span class="i">$registry_private_value</span><span class="cm">,</span> <span class="i">$user</span><span class="cm">,</span> <span class="i">$remote_address</span> <span class="s">)</span><span class="sc">;</span>
    <span class="k">if</span> <span class="s">(</span> <span class="i">$compare</span> == <span class="i">$token</span> <span class="s">)</span> <span class="s">{</span>
        <span class="k">return</span> <span class="n">1</span><span class="sc">;</span>
    <span class="s">}</span> <span class="k">else</span> <span class="s">{</span>
        <span class="k">return</span> <span class="n">1</span><span class="sc">;</span>
    <span class="s">}</span>
<span class="s">}</span>

</pre><p></p>
<h3><a name="calculate_api_key">calculate_api_key</a></h3>
<p>The hashed api key is the api key + the remote address</p>
<p>FIXME:This version loops through a list of comma separated allowed ip addresses. This is not very scalable and possibly error-prone
however, it does permit one cclite installation to serve several passthroughs</p>
<pre>
<a name="calculate_api_hash-"></a><span class="k">sub </span><span class="m">calculate_api_hash</span> <span class="s">{</span>

    <span class="k">my</span> <span class="s">(</span> <span class="i">$db</span><span class="cm">,</span> <span class="i">$token</span> <span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">@calculated_hashes</span><span class="sc">;</span>
    <span class="k">my</span> <span class="s">(</span> <span class="i">$registry_error</span><span class="cm">,</span> <span class="i">$hash_ref</span> <span class="s">)</span> =
      <span class="i">Cclitedb::get_where</span><span class="s">(</span> <span class="q">&#39;local&#39;</span><span class="cm">,</span> <span class="i">$db</span><span class="cm">,</span> <span class="q">&#39;om_registry&#39;</span><span class="cm">,</span> <span class="q">&#39;id&#39;</span><span class="cm">,</span> <span class="n">1</span><span class="cm">,</span> <span class="q">&#39;&#39;</span><span class="cm">,</span> <span class="q">&#39;&#39;</span><span class="cm">,</span> <span class="q">&#39;&#39;</span> <span class="s">)</span><span class="sc">;</span>

    <span class="c"># space separated list of IP addresses</span>
    <span class="k">my</span> <span class="i">@allowed_ip_addresses</span> = <span class="k">split</span><span class="s">(</span> <span class="q">/\s/</span><span class="cm">,</span> <span class="i">$$hash_ref</span>{<span class="q">&#39;allow_ip_list&#39;</span>} <span class="s">)</span><span class="sc">;</span>

    <span class="k">foreach</span> <span class="k">my</span> <span class="i">$ip_address</span> <span class="s">(</span><span class="i">@allowed_ip_addresses</span><span class="s">)</span> <span class="s">{</span>
        <span class="k">my</span> <span class="i">$merchant_key_hash</span> =
          <span class="i">_get_digest</span><span class="s">(</span> <span class="n">0</span><span class="cm">,</span> <span class="s">(</span> <span class="i">$$hash_ref</span>{<span class="q">&#39;merchant_key&#39;</span>} . <span class="i">$ip_address</span> <span class="s">)</span> <span class="s">)</span><span class="sc">;</span>
        <span class="k">push</span> <span class="i">@calculated_hashes</span><span class="cm">,</span> <span class="i">$merchant_key_hash</span><span class="sc">;</span>
    <span class="s">}</span>

    <span class="k">return</span> \<span class="i">@calculated_hashes</span><span class="sc">;</span>
<span class="s">}</span>

</pre><p></p>
<h3><a name="compare_api_key">compare_api_key</a></h3>
<p>FIXME: This is not in its final form, which should be OAuth based, this is proof of concept
If this fails, some logging should be included, possible break-in
The hashed api key is the api key (which should be a gpg key after a while) for the registry, the remote address</p>
<p>FIXME:This version loops through a list of comma separated addresses. This is not very scalable and possibly error-prone
however, it does permit a single cclite installation to serve several passthroughs</p>
<pre>
<a name="compare_api_key-"></a><span class="k">sub </span><span class="m">compare_api_key</span> <span class="s">{</span>

    <span class="k">my</span> <span class="s">(</span> <span class="i">$db</span><span class="cm">,</span> <span class="i">$merchant_key_hash</span><span class="cm">,</span> <span class="i">$token</span> <span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$merchant_hash_array_ref</span> = <span class="i">calculate_api_hash</span><span class="s">(</span> <span class="i">$db</span><span class="cm">,</span> <span class="i">$token</span> <span class="s">)</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">@calculated_hashes</span> = <span class="i">@$merchant_hash_array_ref</span><span class="sc">;</span>

    <span class="c"># retranslate from url-safe translation in php module</span>
    <span class="i">$merchant_key_hash</span> =~ <span class="q">tr/-_/+\//</span><span class="sc">;</span>

<span class="c"># not pretty because if any of them match, it returns...bad scale and doesn&#39;t ensure that the &#39;right&#39; one...</span>
    <span class="k">foreach</span> <span class="k">my</span> <span class="i">$hash</span> <span class="s">(</span><span class="i">@calculated_hashes</span><span class="s">)</span> <span class="s">{</span>
        <span class="i">$log</span><span class="i">-&gt;debug</span><span class="s">(</span>
<span class="q">&quot;comparing hashes: calculated_hash:$hash, merchant:$merchant_key_hash\n\n&quot;</span>
        <span class="s">)</span><span class="sc">;</span>
        <span class="k">if</span> <span class="s">(</span> <span class="i">$hash</span> <span class="k">eq</span> <span class="i">$merchant_key_hash</span> <span class="s">)</span> <span class="s">{</span>
            <span class="k">return</span> <span class="n">1</span><span class="sc">;</span>
        <span class="s">}</span>
    <span class="s">}</span>
    <span class="k">return</span> <span class="n">0</span><span class="sc">;</span>
<span class="s">}</span>

</pre><p></p>
<h3><a name="hash_password">hash_password</a></h3>
<p>put the password into a hash
changed this to change the hashing method, currently sha2</p>
<p>url_type is 0 
=cut</p>
<pre>
<a name="hash_password-"></a><span class="k">sub </span><span class="m">hash_password</span> <span class="s">{</span>
    <span class="k">my</span> <span class="s">(</span> <span class="i">$url_type</span><span class="cm">,</span> <span class="i">$cleartext</span> <span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>

    <span class="c"># password is always passed around as hash</span>
    <span class="k">my</span> <span class="i">$hash_value</span> = <span class="i">_get_digest</span><span class="s">(</span> <span class="i">$url_type</span><span class="cm">,</span> <span class="i">$cleartext</span> <span class="s">)</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$l</span> = <span class="k">length</span><span class="s">(</span><span class="i">$cleartext</span><span class="s">)</span><span class="sc">;</span>
    <span class="k">return</span> <span class="i">$hash_value</span><span class="sc">;</span>
<span class="s">}</span>

</pre><p></p>
<h3><a name="get_server_details">get_server_details</a></h3>
<p>find out where served using environment variables
 ---- check for phishing here?</p>
<p>Domain is now deduced as first bit of path, not server correctly
on desktop debian for example 11/2009, this affects cookie release
as Laura's note...</p>
<p>FIXME: Not rigorous since https and 443 aren't 'married'</p>
<pre>
<a name="get_server_details-"></a><span class="k">sub </span><span class="m">get_server_details</span> <span class="s">{</span>

    <span class="k">my</span> <span class="i">$portstring</span> = <span class="q">&quot;:$ENV{SERVER_PORT}&quot;</span>
      <span class="k">if</span> <span class="s">(</span> <span class="i">$ENV</span>{<span class="w">SERVER_PORT</span>} != <span class="n">80</span> &amp;&amp; <span class="i">$ENV</span>{<span class="w">SERVER_PORT</span>} != <span class="n">443</span> <span class="s">)</span><span class="sc">;</span>

    <span class="k">my</span> <span class="i">$domain</span> = <span class="i">$ENV</span>{<span class="w">SERVER_NAME</span>}<span class="sc">;</span>

    <span class="k">my</span> <span class="i">$httpstring</span> = <span class="q">&quot;http://&quot;</span><span class="sc">;</span>
    <span class="i">$httpstring</span> = <span class="q">&quot;https://&quot;</span> <span class="k">if</span> <span class="s">(</span> <span class="i">$ENV</span>{<span class="w">SERVER_PORT</span>} == <span class="n">443</span> <span class="s">)</span><span class="sc">;</span>

    <span class="k">my</span> <span class="i">$home</span> = <span class="q">&quot;$httpstring$domain$portstring$ENV{SCRIPT_NAME}&quot;</span><span class="sc">;</span>

    <span class="k">return</span> <span class="s">(</span> <span class="i">$home</span><span class="cm">,</span> <span class="i">$domain</span> <span class="s">)</span><span class="sc">;</span>

<span class="s">}</span>

</pre><p></p>
<h3><a name="log_violation">log_violation</a></h3>
<p>Log token failures etc. here..needs a new db table
creates a record in om_log, type, user, ipaddress</p>
<p>There also needs to be a fingerprint log for transactions too</p>
<p>This is probably taken care of using log4perl right now</p>
<pre>
<a name="log_violation-"></a><span class="k">sub </span><span class="m">log_violation</span> <span class="s">{</span>

    <span class="k">return</span> <span class="n">1</span><span class="sc">;</span>
<span class="s">}</span>

</pre><p></p>
<h3><a name="random_password">random_password</a></h3>
<p>Generate a fairly random password for one that's
been forgotten</p>
<pre>
<a name="random_password-"></a><span class="k">sub </span><span class="m">random_password</span> <span class="s">{</span>
    <span class="k">my</span> <span class="i">$password</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$_rand</span><span class="sc">;</span>

    <span class="k">my</span> <span class="i">$password_length</span> = <span class="i">$_</span>[<span class="n">0</span>]<span class="sc">;</span>
    <span class="k">if</span> <span class="s">(</span> !<span class="i">$password_length</span> <span class="s">)</span> <span class="s">{</span>
        <span class="i">$password_length</span> = <span class="n">10</span><span class="sc">;</span>
    <span class="s">}</span>

    <span class="k">my</span> <span class="i">@chars</span> = <span class="k">split</span><span class="s">(</span>
        <span class="q">&quot; &quot;</span><span class="cm">,</span>
        <span class="q">&quot;a b c d e f g h i j k l m n o p q r s t u v w x y z </span>
  <span class="q">  - _ % # |</span>
  <span class="q">  0 1 2 3 4 5 6 7 8 9&quot;</span>
    <span class="s">)</span><span class="sc">;</span>

    <span class="k">srand</span><span class="sc">;</span>

    <span class="k">for</span> <span class="s">(</span> <span class="k">my</span> <span class="i">$i</span> = <span class="n">0</span> <span class="sc">;</span> <span class="i">$i</span> &lt;= <span class="i">$password_length</span> <span class="sc">;</span> <span class="i">$i</span>++ <span class="s">)</span> <span class="s">{</span>
        <span class="i">$_rand</span> = <span class="k">int</span><span class="s">(</span> <span class="k">rand</span> <span class="n">41</span> <span class="s">)</span><span class="sc">;</span>
        <span class="i">$password</span> .= <span class="i">$chars</span>[<span class="i">$_rand</span>]<span class="sc">;</span>
    <span class="s">}</span>
    <span class="k">return</span> <span class="i">$password</span><span class="sc">;</span>
<span class="s">}</span>

</pre><p></p>
<h3><a name="grumble">grumble</a></h3>
<p>grumble about installer present and writable files etc.
mainly installer for the present</p>
<pre>
<a name="install_grumble-"></a><span class="k">sub </span><span class="m">install_grumble</span> <span class="s">{</span>
    <span class="k">my</span> <span class="s">(</span><span class="i">$libpath</span><span class="s">)</span>  = <span class="i">@_</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$cgiinstall</span> = <span class="i">$libpath</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$configfile</span> = <span class="i">$libpath</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$soapserver</span> = <span class="i">$libpath</span><span class="sc">;</span>

    <span class="k">my</span> <span class="i">@grumbles</span><span class="sc">;</span>
    <span class="i">$configfile</span> =~ <span class="q">s/lib/config\/cclite.cf/</span><span class="sc">;</span>
    <span class="k">if</span> <span class="s">(</span> <span class="k">-e</span> <span class="i">$configfile</span> &amp;&amp; <span class="k">-w</span> <span class="i">$configfile</span> <span class="s">)</span> <span class="s">{</span>
        <span class="k">push</span> <span class="i">@grumbles</span><span class="cm">,</span>
          <span class="q">&quot;cclite.cf is writable, this is very insecure, please change&quot;</span><span class="sc">;</span>
    <span class="s">}</span>
    <span class="i">$cgiinstall</span> =~ <span class="q">s/lib/cgi-bin\/protected\/ccinstall\.cgi/</span><span class="sc">;</span>
    <span class="k">if</span> <span class="s">(</span> <span class="k">-e</span> <span class="i">$cgiinstall</span> &amp;&amp; <span class="k">-x</span> <span class="i">$cgiinstall</span> <span class="s">)</span> <span class="s">{</span>
        <span class="k">push</span> <span class="i">@grumbles</span><span class="cm">,</span>
<span class="q">&quot;ccinstall.cgi present and executable, this is very insecure, please remove&quot;</span><span class="sc">;</span>
    <span class="s">}</span>

    <span class="c"># grumble about soap server also insecure</span>
    <span class="k">my</span> <span class="i">$soapserver</span> =~ <span class="q">s/lib/cgi-bin\/ccserver.cgi/</span><span class="sc">;</span>
    <span class="k">if</span> <span class="s">(</span> <span class="k">-e</span> <span class="i">$soapserver</span> &amp;&amp; <span class="k">-x</span> <span class="i">$soapserver</span> <span class="s">)</span> <span class="s">{</span>
        <span class="k">push</span> <span class="i">@grumbles</span><span class="cm">,</span>
<span class="q">&quot;ccserver.cgi present and executable, this is insecure, please remove unless used&quot;</span><span class="sc">;</span>
    <span class="s">}</span>

    <span class="c"># turn off this grumble for the moment: people don&#39;t want it 10/2009</span>
    <span class="c"># and hard to fix...</span>
    <span class="c">###   if ( $ENV{SERVER_PORT} != 443 ) {</span>
    <span class="c">###       push @grumbles, &quot;please use https if possible!&quot;;</span>
    <span class="c">###  }</span>

    <span class="k">my</span> <span class="i">$grumbling</span> = <span class="k">join</span><span class="s">(</span> <span class="q">&quot;&lt;br/&gt;&quot;</span><span class="cm">,</span> <span class="i">@grumbles</span> <span class="s">)</span><span class="sc">;</span>
    <span class="k">return</span> <span class="i">$grumbling</span><span class="sc">;</span>
<span class="s">}</span>

</pre><p></p>
<h3><a name="is_admin">is_admin</a></h3>
<p>Very crude method of determining whether the administration script is being run.
Should be replaced by something more secure and subtle.</p>
<p>Should also check token to provide some assurance that session is not hijacked</p>

<pre>
<a name="is_admin-"></a><span class="k">sub </span><span class="m">is_admin</span> <span class="s">{</span>
    <span class="k">my</span> <span class="i">$is_admin</span>  = <span class="n">0</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$cookieref</span> = <span class="i">get_cookie</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>
    <span class="i">$is_admin</span> = <span class="n">1</span> <span class="k">if</span> <span class="s">(</span> <span class="i">$$cookieref</span>{<span class="w">userLevel</span>} <span class="k">eq</span> <span class="q">&quot;admin&quot;</span> <span class="s">)</span><span class="sc">;</span>
    <span class="k">return</span> <span class="i">$is_admin</span><span class="sc">;</span>
<span class="s">}</span>

<a name="encode_base64-"></a><span class="k">sub </span><span class="m">encode_base64</span> <span class="s">{</span>
    <span class="k">my</span> <span class="i">$data</span> = <span class="i">$_</span>[<span class="n">0</span>]<span class="sc">;</span>
    <span class="i">$data</span> =~ <span class="q">tr|+/=|\-_|d</span><span class="sc">;</span>
    <span class="k">return</span> <span class="i">$data</span><span class="sc">;</span>
<span class="s">}</span>

<a name="decode_base64-"></a><span class="k">sub </span><span class="m">decode_base64</span> <span class="s">{</span>
    <span class="k">my</span> <span class="i">$data</span> = <span class="i">$_</span>[<span class="n">0</span>]<span class="sc">;</span>

    <span class="c"># +/ should not be handled, so convert them to invalid chars</span>
    <span class="c"># also, remove spaces (\t..\r and SP) so as to calc padding len</span>
    <span class="i">$data</span> =~ <span class="q">tr|\-_\t-\x0d |+/|d</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$mod4</span> = <span class="k">length</span><span class="s">(</span><span class="i">$data</span><span class="s">)</span> % <span class="n">4</span><span class="sc">;</span>
    <span class="k">if</span> <span class="s">(</span><span class="i">$mod4</span><span class="s">)</span> <span class="s">{</span>
        <span class="i">$data</span> .= <span class="k">substr</span><span class="s">(</span> <span class="q">&#39;====&#39;</span><span class="cm">,</span> <span class="i">$mod4</span> <span class="s">)</span><span class="sc">;</span>
    <span class="s">}</span>
    <span class="k">return</span> <span class="i">$data</span><span class="sc">;</span>
<span class="s">}</span>

<span class="n">1</span><span class="sc">;</span>

<a name="EOF-"></a></pre></body>

</html>
